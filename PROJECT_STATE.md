PROJECT_STATE.md
1. Project Summary
Current Status: CLI Application
Target Status: Web Application (FastAPI + HTMX/Tailwind)
The current application, spotify_to_tidal, is a Python command-line tool designed to synchronize Spotify playlists and "Liked Songs" to a Tidal account. It features robust track matching logic (fuzzy matching on duration, name, artist), caching (SQLite for failed matches), and concurrency control.
Current capabilities:
Authentication: OAuth2 for Spotify and device-flow style auth for Tidal (currently relies on local browser opening).
Sync Logic: Unidirectional sync (Spotify -> Tidal). Supports full account sync or specific playlists.
Performance: Uses asyncio for concurrent API requests and local caching to speed up repeated runs.
User Feedback: Uses tqdm for CLI progress bars and print statements for logs.
Persistence: Stores credentials and tokens in local YAML files (config.yml, .session.yml).

2. Active Architecture Plan
To convert this CLI tool into a web application accessible from anywhere, we will migrate to a lightweight web framework that supports asynchronous operations natively, matching the existing asyncio logic in the codebase.
Technology Stack
Backend: FastAPI.
Reasoning: The existing codebase heavily utilizes asyncio. FastAPI is built on ASGI and handles async natively, unlike Flask which requires workarounds. It also provides automatic API documentation (Swagger UI).
Frontend: Jinja2 Templates + HTMX + Tailwind CSS.
Reasoning: This keeps the stack Python-centric and avoids the complexity of a separate React/Vue build pipeline. HTMX is ideal for "live" updates (progress bars, logs) via Server-Sent Events (SSE) without complex JavaScript.
Database/Session:
SQLite (Enhanced): Continue using SQLite for the matching cache (.cache.db).
Session Management: Move from flat YAML files (.session.yml) to secure server-side session cookies (signed) to support multi-user usage (or at least secure single-user usage on a remote server).
Async Task Management: BackgroundTasks (FastAPI native) or a lightweight queue to handle long-running sync jobs without blocking the HTTP response.
Architectural Changes Required
Decoupling IO: Remove all print(), input(), and webbrowser.open() calls. These must be replaced with return values (URLs) or log streams.
Auth Flow Refactor:
Spotify: Implement standard OAuth2 Authorization Code flow with a callback endpoint.
Tidal: Capture the login URL generated by tidalapi and display it on the web UI for the user to click, instead of auto-opening a browser.
Progress Streaming: Replace tqdm with a generator approach that yields status updates to the frontend via Server-Sent Events (SSE).

3. Implementation Checklist
Copilot should follow this strict order of operations.
Phase 1: Project Restructuring & Initialization

Create Web Directory Structure:
Create src/web/ containing main.py, routers/, templates/, and static/.
Create src/web/core/ for shared logic.

Install Web Dependencies:
Add fastapi, uvicorn, jinja2, python-multipart, httpx, and itsdangerous (for sessions) to pyproject.toml.

Initialize FastAPI App:
Create basic main.py entry point.
configure StaticFiles and Jinja2Templates.
Phase 2: Backend Refactoring (Decoupling)

Refactor auth.py for Web (Spotify):
Create get_spotify_auth_url(): Returns the URL instead of handling the flow internally.
Create handle_spotify_callback(code): Exchanges code for token and returns the session object.
Remove reliance on config.yml for secrets; use Environment Variables (os.environ).

Refactor auth.py for Web (Tidal):
Modify open_tidal_session to separate the "login request" from the "wait for login".
Create a function that returns the verification_uri and user_code to the UI.

Refactor sync.py (Logging):
Remove tqdm and print.
Create a SyncStatus class or async generator that yields events (e.g., {"event": "progress", "current": 10, "total": 100, "message": "Searching..."}).
Phase 3: API & Session Management

Session Middleware:
Implement signed cookie sessions to store the serialized Spotify and Tidal tokens.
Create a dependency get_current_user_tokens to protect routes.

Auth Routes:
GET /auth/spotify/login: Redirects to Spotify.
GET /auth/spotify/callback: Handles return, sets cookie.
GET /auth/tidal/login: Returns the link/code for the user to click.
POST /auth/tidal/check: Checks if the Tidal login is complete.
Phase 4: Core Logic Integration

Playlist Endpoint:
GET /api/playlists: Uses sync.get_playlists_from_spotify to return JSON list of available playlists to sync.

Sync Endpoint (Background Task):
POST /api/sync: Accepts a playlist ID (or 'all'). Starts the background sync process. Returns a Job ID.

Progress Stream (SSE):
GET /api/sync/stream: A Server-Sent Events endpoint that consumes the generator created in Phase 2 to push updates to the UI.
Phase 5: Frontend Construction (HTMX + Jinja2)

Login Page (login.html):
Two cards: "Connect Spotify" (redirect button) and "Connect Tidal" (Show code + Link).

Dashboard (dashboard.html):
Show list of Spotify playlists with checkboxes.
"Sync Favorites" toggle.
"Start Sync" button.

Live Console (components/console.html):
A div that connects to the SSE endpoint to show real-time logs and a CSS-based progress bar.
Phase 6: Deployment & Final Polish

Environment Configuration:
Create .env.example file.

Dockerization:
Create Dockerfile (Python 3.11 slim).
Create docker-compose.yml (App + Volume for cache database).

Cleanup:
Remove CLI-specific arguments from __main__.py (or keep them as a legacy entry point, ensuring src/spotify_to_tidal remains importable).